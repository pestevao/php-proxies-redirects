<?phpini_set('date.timezone', 'Europe/Lisbon');date_default_timezone_set('Europe/Lisbon');// Report all PHP errorserror_reporting(-1);error_reporting(E_ALL);ini_set('display_errors', 1);$key = '';$mode = '';$count = '';$defaultRule = 'rule_default';$rulesArray = parse_ini_file("rules.ini", true);function doProxy($url, $conn_timeout=null, $global_timeout=null) {	/*	 * Original SOURCE CODE	 * https://gist.github.com/iovar/9091078	 *	 */	$method = $_SERVER['REQUEST_METHOD'];	$headers = getallheaders();	$headers_str = [];	// unset some current request headers	if (isset($headers['Host'])) {		unset($headers['Host']);	}	// appended again bellow	if (isset($headers['X-Original-Request-Scheme'])) {		unset($headers['X-Original-Request-Scheme']);	}	if (isset($headers['X-Original-Url'])) {		unset($headers['X-Original-Url']);	}	if (isset($headers['X-Forwarded-Host'])) {		unset($headers['X-Forwarded-Host']);	}	if (isset($headers['X-Forwarded-Url'])) {		unset($headers['X-Forwarded-Url']);	}	if (isset($headers['X-Forwarded-For'])) {		unset($headers['X-Forwarded-For']);	}	if (isset($headers['X-Forwarded-By'])) {		unset($headers['X-Forwarded-By']);	}	if (isset($headers['X-Forwarded-Unique-Id'])) {		unset($headers['X-Forwarded-Unique-Id']);	}	// itenerate remaining current request headers	foreach ($headers as $key => $value) {		$headers_str[] = $key.": ".$value;	}	// append some headers to the request	array_push($headers_str, "X-Original-Request-Scheme: " . $_SERVER['REQUEST_SCHEME']);	array_push($headers_str, "X-Original-Url: " . $_SERVER['REQUEST_URI']);	array_push($headers_str, "X-Forwarded-Host: " . $_SERVER['SERVER_NAME']);	array_push($headers_str, "X-Forwarded-Url: " . $_SERVER['REQUEST_SCHEME'] . "://" . $_SERVER['SERVER_NAME'] . $_SERVER['REQUEST_URI']);	array_push($headers_str, "X-Forwarded-For: " . $_SERVER['REMOTE_ADDR'] . ":" . $_SERVER['REMOTE_PORT']);	array_push($headers_str, "X-Forwarded-By: " . $_SERVER['SERVER_ADDR']);	array_push($headers_str, "X-Forwarded-Unique-Id: " . $_SERVER['UNIQUE_ID']);	$ch = curl_init($url);	curl_setopt($ch, CURLOPT_URL, $url);	curl_setopt($ch, CURLOPT_ENCODING, '');	if ($method !== 'GET') {		curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);	}	if ($method == "PUT" || $method == "PATCH" || $method == "POST") {		curl_setopt($ch, CURLOPT_POST, true);		if (empty($_FILES)) {			$data_str = file_get_contents('php://input');			curl_setopt($ch, CURLOPT_POSTFIELDS, $data_str);			//error_log($method.': '.$data_str.serialize($_POST).'\n',3, 'err.log');		} else {			$data_str = array();			// remove Content-Type and Content-Length			$header_str_matches = preg_grep("/^Content-(.*)/is", $headers_str);			if (!empty($header_str_matches)) {				foreach(array_keys($header_str_matches) as $header_str_match) {					unset($headers_str[$header_str_match]);				}				array_push($headers_str, "Content-Type: multipart/form-data");				ksort($headers_str);			}			foreach ($_FILES as $key => $value) {				if (function_exists('curl_file_create')) {					$file = curl_file_create(realpath($_FILES[$key]['tmp_name']), $_FILES[$key]['type'], basename($_FILES[$key]['name']));				} else { // 					$file = '@' . realpath($_FILES[$key]['tmp_name']) . ';filename=' . basename($_FILES[$key]['name']);				}				$data_str[$key] = $file;			}			curl_setopt($ch, CURLOPT_POSTFIELDS, array_merge($data_str, $_POST));		}	}	if (!empty($conn_timeout)) {		curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, intval($conn_timeout));	}	if (!empty($global_timeout)) {		curl_setopt($ch, CURLOPT_TIMEOUT, intval($global_timeout));	}	curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);	curl_setopt($ch, CURLOPT_HEADER, true);	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);	curl_setopt($ch, CURLOPT_HTTPHEADER, $headers_str);	$result = curl_exec($ch);	$info = curl_getinfo($ch);	curl_close($ch);	// Then, after your curl_exec call:	$headers = substr($result, 0, $info['header_size']);	$body = substr($result, $info['header_size']);	header("Content-Type: " . $info['content_type']);	http_response_code($info['http_code']);	// get the last response header	// work around for FOLLOWLOCATION option	if (preg_match("/(HTTP\/(?:2.[0]|1.[01]) 200 OK)(.*)/is", $headers, $match)) {		$headers = $match[0];	}	// build an array with all headers	$headers = explode(PHP_EOL, $headers);	foreach(array_filter(array_map('trim', $headers)) as $header) {		if (preg_match("/^.*(Expires|Pragma|Set-Cookie|ETag|Cache\-Control).*?:(.*)$/is", $header, $matches)) {			header($matches[0]);		}	}	echo $body;}// Function to recursively search for a given valuefunction arraySearchId($searchValue, $array, $idPath=array()) {    if (is_array($array) && count($array) > 0) {        foreach($array as $key => $value) {            $tempPath = $idPath;            // Adding current key to search path            array_push($tempPath, $key);              // Check if this value is an array            // with atleast one element            if (is_array($value) && count($value) > 0) {                $res_path = arraySearchId($searchValue, $value, $tempPath);                if ($res_path != null) {                    return $res_path;                }            } elseif ($tempPath[(count($tempPath)-2)] == 'sourceDomain') {				// Matches a literal result				if ($value == $searchValue) {					array_push($tempPath, 'literal');					return $tempPath;				// Matches a similar result				} elseif (preg_match("/^".$value."/i",$searchValue)) {					array_push($tempPath, 'regex');					return $tempPath;				}            }        }    }    return null;}function redirectOrProxy($line) {	global $key, $mode, $count;	// create $mode array for redirect or rewrite	$mode = explode(",", $line);	// $key for check if redirect or...	$key = array_search('redirect', $mode);	// ... rewrite and the level where these exists	if (!is_array($key) || $key == '') {		$key = array_search('rewrite', $mode);	}	// count the elements in $mode array	$count = (count($mode)-1);}$searchPath = arraySearchId($_SERVER['SERVER_NAME'], $rulesArray);// no rule match protectionif (!isset($searchPath[0])) {	$searchPath[0] = $defaultRule;}$result = $rulesArray[$searchPath[0]];if ($result['enabled'] == 'true') {	// call function to generate mandatory info	redirectOrProxy($result['mode']);	// remove current path	// as it may work on /somefolder instead of /	$_SERVER['REQUEST_URI'] = str_replace(str_replace($_SERVER['DOCUMENT_ROOT'], "", __DIR__), "", $_SERVER['REQUEST_URI']);	// redirect	if ($mode[$key] == 'redirect') {		// remove any _GET vars		$_SERVER['REQUEST_URI'] = strtok($_SERVER['REQUEST_URI'], '?');		// check if matchUrl catch something		preg_match("~^" . $result['matchUrl'] . "$~i", $_SERVER['REQUEST_URI'], $matches);		if (!isset($matches) || count($matches) == 0) {			// didn't catch anything			// unset previous array			unset($result);			// go to defaultRule			$result = $rulesArray[$defaultRule];			// call function to generate mandatory info			redirectOrProxy($result['mode']);		}		// configured to append Url to Destination?		if ($result['appendMatchUrlToDestinationUrl'] == 'true') {			// check if destinationUrl last character is /			// if so, remove it from the beginning of $_SERVER['REQUEST_URI']			if (substr($result['destinationUrl'], -1) == '/') {				$result['destinationUrl'] .= ltrim($_SERVER['REQUEST_URI'], "/");			// if not, rely on $_SERVER['REQUEST_URI'] and just append it			} else {				$result['destinationUrl'] .= $_SERVER['REQUEST_URI'];			}		}		// configured to append QueryString to Destination?		// if so		if ($result['appendQueryStringToDestinationUrl'] == 'true') {			// how $_SERVER['REQUEST_URI'] already have QueryString			// check if appendMatchUrlToDestinationUrl is false (not proccessed earlier)			// and $_SERVER['QUERY_STRING'] is not empty to append it			if ($_SERVER['QUERY_STRING'] != '') {				$result['destinationUrl'] .= "?" . $_SERVER['QUERY_STRING'];							}		// if not, remove it		} else {			$result['destinationUrl'] = strtok($result['destinationUrl'], '?');		}		// check for redirect code and validate it		if ($mode[$count-$key] == '' || !preg_match("/30[12378]/i", $mode[$count-$key])) {			$mode[$count-$key] = '302';		}		header("Expires: Wed, 12 Jul 1978 09:15:00 GMT");		header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT");		header("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");		header("Cache-Control: post-check=0, pre-check=0", FALSE);		header("Pragma: no-cache");		header("Location: " . $result['destinationUrl'], TRUE, $mode[$count-$key]);	// rewrite	} elseif ($mode[$key] == 'rewrite') {		// check for forceHttps defined		if (isset($result['forceHttps']) && ($result['forceHttps'] == "true" && strpos($_SERVER['REQUEST_SCHEME'], "https") !== 0)) {			header("Location: https://" . $_SERVER['SERVER_NAME'] . $_SERVER['REQUEST_URI'], TRUE, 301);		} else {			doProxy($result['destinationUrl'] . $_SERVER['REQUEST_URI'], (isset($result['proxyConnectTimeout']) && !empty($result['proxyConnectTimeout']) ? $result['proxyConnectTimeout'] : null), (isset($result['proxyGlobalTimeout']) && !empty($result['proxyGlobalTimeout']) ? $result['proxyGlobalTimeout'] : null));		}	} else {		// unkown $mode	}} else {	// rule disabled}?>